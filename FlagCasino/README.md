**Challenge Name**: FlagCasino

**Challenge Description**: The team stumbles into a long-abandoned casino. As you enter, the lights and music whir to life, and a staff of robots begin moving around and offering games, while skeletons of prewar patrons are slumped at slot machines. A robotic dealer waves you over and promises great wealth if you can win - can you beat the house and gather funds for the mission?

**Challenge Categoty:** Reverse Engineering

**Challenge Points**: 950

**Difficulty**: Very Easy

## Content
Ghidra was used as the Decompiler in KaliLinux Virtual Environment.

### On the Surface 
Upon downloading the required files from Hack the Box Website and running the `casino` file in terminal using: `./casino` we are presented with:
```
[ ** WELCOME TO ROBO CASINO **]
     ,     ,
    (\____/)
     (_oo_)
       (O)
     __||__    \)
  []/______\[] /
  / \______/ \/
 /    /__\
(\   /____\
---------------------
[*** PLEASE PLACE YOUR BETS ***]
> j
[ * INCORRECT * ]
[ *** ACTIVATING SECURITY SYSTEM - PLEASE VACATE *** ]
```
Where we have to input the correct sequence of characters(i.e. String, which is our target/Flag that we have to find in order to pwn it).

### Decompilation and Analysis
Upon loading the `casino` file into Ghidra, it presents us with this in the Decompile Window:
```c
undefined8 main(void)

{
  int iVar1;
  char local_d;
  uint local_c;
  
  puts("[ ** WELCOME TO ROBO CASINO **]");
  puts(
      "     ,     ,\n    (\\____/)\n     (_oo_)\n       (O)\n     __||__    \\)\n  []/______\\[] /\n   / \\______/ \\/\n /    /__\\\n(\\   /____\\\n---------------------"
      );
  puts("[*** PLEASE PLACE YOUR BETS ***]");
  local_c = 0;
  while( true ) {
    if (0x1c < local_c) {
      puts("[ ** HOUSE BALANCE $0 - PLEASE COME BACK LATER ** ]");
      return 0;
    }
    printf("> ");
    iVar1 = __isoc99_scanf(&DAT_001020fc,&local_d);
    if (iVar1 != 1) break;
    srand((int)local_d);
    iVar1 = rand();
    if (iVar1 != *(int *)(check + (long)(int)local_c * 4)) {
      puts("[ * INCORRECT * ]");
      puts("[ *** ACTIVATING SECURITY SYSTEM - PLEASE VACATE *** ]");
                    /* WARNING: Subroutine does not return */
      exit(-2);
    }
    puts("[ * CORRECT *]");
    local_c = local_c + 1;
  }
                    /* WARNING: Subroutine does not return */
  exit(-1);
}
```
This is not the actual code behind the `casino` program but a speculation form Ghidra of how the actual code might be structured by analysing the underlying assembly.

By looking at the decompiled code, we already get that there are 3 major Variables of whose role in the code is described below.
#### **iVar1**: 
- To check if there was any input from the user(`iVar1 = __isoc99_scanf(&DAT_001020fc,&local_d);`) [Line 20]
- To Store a random value generated from `rand()` which uses the User Input as seed in `srand()` [Line23]
- To check against the correct value stored in `check` array (This `check` array is an external array(not stated in the code) which stores the target set of strings) [Line24]
#### **local_d**:
- To take User Input character and assign it to `ivar1`. [Line20]
#### **local_c**:
- Serves as the index offset for the `check` array pointer. [Line24, Line31]

#### What does the program do?
It takes a User Input, uses that User Input as a seed in `srand()` to serve as seed for the subsequent `rand()` function.
This `rand()` function then generates a pseudo-random number from the provided seed which gets stores in `iVar1` and this `iVar1` is later compared against elements of `check` array.

So the `check` array pointer basically stores the pseudo-random numbers generated by the `rand()` fucntion of which seed is set by `srand()` for a specific sequence of characters which is the **flag** we are looking for.

### Approach
1. Find the `check` array, it would look something like this in Ghidra:
<img width="1168" height="666" alt="image" src="https://github.com/user-attachments/assets/9755bb5e-7a46-4faf-94b2-51e72d8a7b29" />

2. The selection(array values) is copied and stored in a textfile(hackerman.txt), but the values are in Little Endian form, we have to run a python script to arrange those values in a more manageable format; The below script was used for that purpose:
```py
with open("hackerman.txt", 'r') as file:
    content = file.read().split()
    counter = 0
    while counter < len(content):
        temp = content[counter:counter+4][::-1]
        print(f"{temp[0]}{temp[1]}{temp[2]}{temp[3]}")
        counter += 4
```
2. Generated for each possible User Input within the ascii range as seed for `rand()` funciton mapping using the below C code:
```c
int main(){
	for (int i = 0; i < 256; i++){
	srand(i);
	printf("%d : %08x", i, rand());
	printf("\n");
}
	//srand(100);
	//printf("%d",rand());
    return 0;
}
```
3. Step2's(a string) output is stored in the below script as `check_scope` and the below script is run:
```py
proc_data1 = check_scope.split("\n")[0:256]
mapping = {}
amog = ''

for i in range(256):
    mapping[str(proc_data1[i].split(" : ")[0])] = proc_data1[i].split(" : ")[1]

with open("hackerman.txt", 'r') as file:
    content = file.read().split()
    counter = 0
    temp1 = []
    while counter < len(content):
        temp = content[counter:counter+4][::-1]
        temp1.append(temp[0]+temp[1]+temp[2]+temp[3])
        counter += 4

for i in temp1:
    for key, val in mapping.items():
        if i == val:
            amog += chr(int(key))

print(amog)
```
This Gives us our Flag: `HTB{r4nd_1s_v3ry_pr3d1ct4bl3}`
